#!/usr/bin/python3
#
# SBILL version 1.4.1
#
# Query SLURM billing per job through SLURM sacct command
#
# Copyright (c) 2023, Somrath Kanoksirirath.
# All rights reserved under BSD 3-clause license.
#
# Dependencies:
# + python (>=3.1.0)  -- subprocess, math, os, sys, str.format
# + numpy  (>=1.11.0) -- Optional, only for --histogram option
# + SLURM
#
__version__ = '1.4.1 (06 April 2023)'
__HPC__ = 'XXX HPC of XXX'

# Set up
key = ['billing','cpu','gres/gpu:a100']  # Keywords to be captured from alloctres field of sacct
isRestricted = False                      # True = display only jobs related by associated accounts
SLURM_STARTDATE = '2023-04-13T00:00:00'

Service = 'Service'
calService = lambda billing, elapsedraw : billing*elapsedraw/60/60/100
ServiceDecimal = 3

CPUusage = 'CPU-core-hour'
calCPUusage = lambda ncpu, elapsedraw : ncpu*elapsedraw/60/60
CPUusageDecimal = 2

GPUusage = 'GPU-card-hour'
calGPUusage = lambda ngpu, elapsedraw : ngpu*elapsedraw/60/60
GPUusageDecimal = 2

GLOBAL_SBILL_DEFAULT_FORMAT = ['JobID','JobName%10','Account','Partition','NCPUS','NGPUS','Elapsed','State',Service]

def show_sbill_usage():
    print("Usage: sbill [OPTIONS]")
    print("")
    print("Query slurm billing per job (warpping slurm sacct command)")
    print("")
    print("OPTIONS:")
    print("  -A, --accounts=<slurm_account_list>")
    print("      specify one or more accounts")
    print("")
    print("  -a, --allusers")
    print("      display jobs of all users")
    print("")
    print("  -L, --allclusters")
    print("      display jobs ran on all clusters")
    print("")
    print("  -E, --endtime=<slurm_end_time>")
    print("      display only jobs that began running before this end time")
    print("")
    print("  -o, --format=<"+Service+", Billing, NGPUS, "+CPUusage+", "+GPUusage+" and slurm_sacct_fields>")
    print("      specify display fields, e.g., JobID, JobName, State%9, "+Service+", ...")
    print("      The additional integer after % will specify the number of characters of the field")
    print("      SBILL_FORMAT environment variable will override the default format.")
    print("      Please note that "+CPUusage+" and "+GPUusage+" are of allocation.")
    print("")
    print("  -h, --help")
    print("      show this help message and exit")
    print("")
    print("  -H, --histogram=<number_of_bins>")
    print("      compute histogram of the displayed jobs using the input number of bins")
    print("")
    print("  -j, --jobs=<slurm_job>")
    print("      display only the specified job")
    print("")
    print("  --name=<slurm_jobname_list>")
    print("      display only jobs that have these names")
    print("")
    print("  -i, --nnodes=<min[-max]>")
    print("      display only jobs that ran with this specified number of nodes")
    print("")
    print("  --noconvert")
    print("      do not convert units, e.g., 2048M won't get converted to 2G")
    print("")
    print("  -N, --nodelist=<slurm_node_list>")
    print("      display only jobs that ran on these nodes")
    print("")
    print("  -r, --partition=<slurm_partition_list>")
    print("      display only jobs that ran on these partitions")
    print("")
    print("  --to_csv=<filename>")
    print("      save as .csv file")
    print("")
    print("  -S, --starttime=<slurm_start_time>")
    print("      display only jobs that began running after this start time")
    print("      Note: on this system, the billing start at", SLURM_STARTDATE)
    print("")
    print("  --state=<COMPLETED,FAILED,CANCELED,TIMEOUT,...>")
    print("      display only jobs marked with these state (no abbreviation)")
    print("")
    print("  --sumby=[Account,User]")
    print("      sum the "+Service+" of the displayed jobs by [Account or User]")
    print("")
    print("  -u, --user=<slurm_user_list>")
    print("      display only jobs submitted by these users")
    print("")
    print("  --units=[KMGTP]")
    print("      display values in the specified unit type (Override --noconvert)")
    print("")
    print("  -V, --version")
    print("      print version and exit")
    print("")
    print("  -X, --summary")
    print("      display only the summary report")
    print("")
    print("  ---------")
    print("")
    print("  --> configured for " + __HPC__)
    print("")
    # Hidden option
    #print("  --other_sacct_opts=(SLURM SACCT OPTIONS)")
    #print("      append other slurm sacct options, please use with caution")
    #print("")
    #
    # --allusers may conflict with --user= --> latest take effect --> let sacct fix it


# ----- import libraries 1 -----
from sys import argv, exit
from subprocess import check_output, CalledProcessError


# ------------- Parse arguments ----------
i = 1
slurm_filter_opts = []
slurm_format_opts = []
slurm_other_format_opts = []
slurm_other_sacct_opts = []

temp_opt = []
state_selected = []
is_show_job_histogram = False
nbin_histogram = 1
range_minmax = []
is_show_total_SU = True
sum_by = []
csv_outfile = ''
is_show_only_summary = False

def parse_filter_opts(i, opt1, opt2, has_argv, var=slurm_filter_opts):
    # Case 1: -X xxx
    if opt1 != '' and argv[i] == opt1 :
        var.append(argv[i])
        i += 1
        if has_argv :
            if argv[i].startswith('-') :
                print('Incorrect input argument for '+argv[i-1]+' :', argv[i], 'does not seem to be valid.')
                exit(1)
            else:
                var.append(argv[i])
                i += 1
    # Case 2: -Xxxx
    elif opt1 != '' and has_argv and argv[i].startswith(opt1) :
        var.append(argv[i])
        i += 1
    # Case 3: --X xxx
    elif opt2 != '' and argv[i] == opt2 :
        var.append(argv[i])
        i += 1
        if has_argv :
            if argv[i].startswith('-') :
                print('Incorrect input argument for '+argv[i-1]+' :', argv[i], 'does not seem to be valid.')
                exit(1)
            else:
                var.append(argv[i])
                i += 1
    # Case 4: --X=xxx
    elif opt2 != '' and has_argv and argv[i].startswith(opt2+'=') :
        if argv[i] == opt2+'=' :
            print('Missing an input after ::', argv[i])
            exit(1)
        else:
            var.append(argv[i])
            i += 1

    return i


while i < len(argv) :
    j = i
    # Slurm filter options
    i = parse_filter_opts(i,'-A','--accounts', has_argv=True)
    if i != j : continue ;
    i = parse_filter_opts(i,'-a','--allusers', has_argv=False)
    if i != j : continue ;
    i = parse_filter_opts(i,'-L','--allclusters', has_argv=False)
    if i != j : continue ;
    i = parse_filter_opts(i,'-E','--endtime', has_argv=True)
    if i != j : continue ;
    i = parse_filter_opts(i,'-j','--jobs', has_argv=True)
    if i != j : continue ;
    i = parse_filter_opts(i,'','--name', has_argv=True)
    if i != j : continue ;
    i = parse_filter_opts(i,'-i','--nnodes', has_argv=True)
    if i != j : continue ;
    i = parse_filter_opts(i,'-N','--nodelist', has_argv=True)
    if i != j : continue ;
    i = parse_filter_opts(i,'-r','--partition', has_argv=True)
    if i != j : continue ;
    i = parse_filter_opts(i,'-S','--starttime', has_argv=True)
    if i != j : continue ;
    i = parse_filter_opts(i,'-u','--user', has_argv=True)
    if i != j : continue ;

    # Sbill filter options
    i = parse_filter_opts(i,'-s','--state', has_argv=True, var=temp_opt) # Borrow
    if len(temp_opt) > 1 :
        state_selected = temp_opt[1].split(',')
    elif len(temp_opt) == 1 :
        if temp_opt[0].startswith('-s') :
            state_selected = temp_opt[0][2:].split(',')
        elif temp_opt[0].startswith('--state=') :
            state_selected = temp_opt[0][8:].split(',')
    if i != j : temp_opt = [] ; continue ;

    # Format options
    i = parse_filter_opts(i,'-o','--format', has_argv=True, var=temp_opt) # Borrow
    if len(temp_opt) > 1 :
        slurm_format_opts = temp_opt[1].split(',')
    elif len(temp_opt) == 1 :
        if temp_opt[0].startswith('-o') :
            slurm_format_opts = temp_opt[0][2:].split(',')
        elif temp_opt[0].startswith('--format=') :
            slurm_format_opts = temp_opt[0][9:].split(',')
    if i != j : temp_opt = [] ; continue ;

    # Output options
    i = parse_filter_opts(i,'-H','--histogram', has_argv=True, var=temp_opt) # Borrow
    if len(temp_opt) > 1 :
        is_show_job_histogram = True
        try:
            nbin_histogram = max(int(temp_opt[1]), 1)
        except ValueError :
            print('Invalid input argument in -H, --histogram option :: cannot convert requested \"nbin\" to a proper numbers')
            exit(1)
    elif len(temp_opt) == 1 :
        is_show_job_histogram = True
        if temp_opt[0].startswith('-H') :
            nbin_histogram = temp_opt[0][2:]
        elif temp_opt[0].startswith('--histogram=') :
            nbin_histogram = temp_opt[0][12:]
        else:
            print('Invalid format of -H or --histogram option')
            exit(1)
        try:
            nbin_histogram = max(int(nbin_histogram), 1)
        except ValueError :
            print('Invalid input argument in -H, --histogram option :: cannot convert requested \"nbin\" to a proper numbers')
            exit(1)
    if i != j : temp_opt = [] ; continue ;

    # Output option
    if argv[i].startswith('--range='):
        try:
            temp = argv[i][8:].split('-')
            if len(temp) == 1 :
                range_minmax = [float(temp[0])]
            elif len(temp) > 1 :
                range_minmax = [float(temp[0]), float(temp[1])]
            else:
                print('Invalid format of --range option')
                exit(1)
        except ValueError :
            print('Invalid input argument in', argv[i],':: cannot convert \"'+argv[i][8:]+'\" to proper numbers, i.e., min and max')
            exit(1)
        i += 1
        continue

    # Output option
    if argv[i].startswith('--sumby') :
        if argv[i][8:].lower() == 'account' :
            sum_by = 'Account'
        elif argv[i][8:].lower() == 'user' :
            sum_by = 'User'
        elif len(argv[i][8:]) != 0 :
            print('Unregcognized input argument in --sumby= :: only Account or User are valid.')
            exit(1)
        i += 1
        continue

    # File output option
    if argv[i].startswith('--to_csv=') :
        csv_outfile = argv[i][9:]
        if csv_outfile == '' :
            print('Missing an input after :: --to_csv=')
            exit(1)
        else:
            i += 1
            continue

    # Other sacct options
    i = parse_filter_opts(i,'','--noconvert', has_argv=False, var=slurm_other_format_opts)
    if i != j : continue ;
    i = parse_filter_opts(i,'','--units', has_argv=True, var=slurm_other_format_opts)
    if i != j : continue ;

    # Summary report only
    if argv[i] == '-X' or argv[i] == '--summary' :
        is_show_only_summary = True
        i += 1
        continue

    # Other options
    if argv[i] == '-V' or argv[i] == '--version' :
        slurm = str(check_output(['sinfo','-V']).decode('ascii'))
        print('sbill',__version__,'on',__HPC__,'utilizing', slurm, end='')
        exit(0)
    if argv[i] == '-h' or argv[i] == '--help' :
        show_sbill_usage()
        exit(0)
    if argv[i].startswith('--other_sacct_opts="') :
        slurm_other_sacct_opts = argv[i][20:-1].split(' ')
        i += 1
        continue

    if i == j :
        print('Unknown options/arguments ::', argv[i])
        exit(1)


# ------  function to get data from SLURM ------

def get_tres(string, key):
    start = string.find(key)
    if start == -1 :
        return 0
    else:
        start += len(key)
        end = string.find(',', start)
        return int(string[start:end])


def parse_alloctres(datain, key, maxcharperline=150):

    nrow = datain.count('\n')
    dataout = {}
    for k in key :
        dataout[k] = [0]*nrow

    if nrow == 0 :
        return dataout
    else:
        test = datain.find("\n", 0, maxcharperline)
        while test == -1 :
            maxcharperline += 100
            test = datain.find("\n", 0, maxcharperline)

    start = 0
    for i in range(nrow):
        end = datain.find("\n", start, start+maxcharperline)
        temp = datain[start:end]

        for k in key :
            dataout[k][i] = get_tres(temp, k + '=')

        start = end + 1

    return dataout


def parse_sacct(datain, key, sep, maxcharperline=150):

    nrow    = datain.count('\n')
    ncol    = len(key)
    dataout = {}
    for k in key :
        dataout[k] = [None]*nrow

    if nrow == 0 :
        return dataout
    else:
        test = datain.find("\n", 0, maxcharperline)
        while test == -1 :
            maxcharperline += 100
            test = datain.find("\n", 0, maxcharperline)

    start = 0
    for i in range(nrow):
        end = datain.find("\n", start, start+maxcharperline)
        temp = datain[start:end]

        markL = 0
        markR = temp.find(sep, markL)
        for k in key :
            dataout[k][i] = temp[markL:markR]
            markL = markR+1
            markR = temp.find(sep, markL)

        start = end + 1

    return dataout


def data_from_sacct(sacct_opts, columns, sep='|', isAllocTres=False):
    try:
        data = check_output(['sacct'] + sacct_opts, shell=False)
    except CalledProcessError :
        print('sbill: error: Non-zero return code from sacct command.')
        exit(1)
    else:
        if isAllocTres:
            return parse_alloctres(data.decode('utf-8'), columns)
        else:
            return parse_sacct(data.decode('utf-8'), columns, sep)


def AssocAccount_from_sacctmgr():
    try:
        data = check_output(['sacctmgr','show','assoc','-P','format=user,qos'], shell=False)
    except CalledProcessError :
        print('sbill: error: Non-zero return code from sacctmgr command.')
        exit(1)
    else:
        data = parse_sacct(data.decode('utf-8'), key=['User','QOS'], sep='|') # Borrow

    return data['QOS']


# ------------ Main computation  ------------

# Parse AllocTres
format_opts = ['--format=alloctres','-X','-p','--delimiter=,','--noheader']
slurm_opts = format_opts + slurm_filter_opts + slurm_other_sacct_opts
usage = data_from_sacct(slurm_opts, columns=key.copy(), sep=None, isAllocTres=True)

# Get other essential fields
format_opts = ['--format=jobid,account,state,elapsedraw','-X','-p','--noheader']
col_names = ['JobID','Account','State','ElapsedRaw']
slurm_opts = format_opts + slurm_filter_opts + slurm_other_sacct_opts
info = data_from_sacct(slurm_opts, columns=col_names, sep='|')

# Merge together
usage.update(info)


# ---- SBILL filter

def pop_usage(mask):
    for k in list(usage.keys()):
        iremain = -1
        for i in range(len(mask)):
            if mask[i] :
                iremain += 1
            else:
                del usage[k][iremain+1]


def filter_usage(Col, List):
    nrow = len(usage['JobID'])
    mask = [False]*nrow
    for nr in range(nrow):
        mask[nr] = usage[Col][nr].lower().startswith( tuple(k.lower() for k in List) )
    pop_usage(mask)


# I. Account
# Only show jobs submitted using associated accounts
if isRestricted :
    assoc = list(dict.fromkeys( AssocAccount_from_sacctmgr() )) # Remove duplicates
    filter_usage('Account', assoc)

# II. State
if len(state_selected) != 0 :
    filter_usage('State', state_selected)


# Compute Service and core-hour
usage['ElapsedRaw'] = [ int(num) if num.isdigit() else 0 for num in usage['ElapsedRaw'] ]
usage[Service]  = [ calService(b,s) for b,s in zip(usage[key[0]],usage['ElapsedRaw']) ]
usage[CPUusage] = [ calCPUusage(ncpu,s) for ncpu,s in zip(usage[key[1]],usage['ElapsedRaw']) ]
usage[GPUusage] = [ calGPUusage(ngpu,s) for ngpu,s in zip(usage[key[2]], usage['ElapsedRaw']) ]

# Filter range before sum
if len(range_minmax) >= 1 :
    if len(range_minmax) == 1 :
        mask = [ range_minmax[0]<=value for value in usage[Service] ]
    else:
        mask = [ (range_minmax[0]<=value) & (value<=range_minmax[1]) for value in usage[Service] ]
    pop_usage(mask)

# If no jobs remain after being sorted out
if len(usage['JobID']) == 0 :
    if isRestricted :
        print('*** No (associated) jobs to be displayed ***')
    else:
        print('*** No jobs to be displayed ***')
    exit(0)

# Sum
Total_SU_spent = sum( usage[Service] )
Total_CPUusage_obtained = sum( usage[CPUusage] )
Total_GPUusage_obtained = sum( usage[GPUusage] )

# ------------ Additional information ------------

# Get format options
if len(slurm_format_opts) == 0 :
    from os import getenv
    env_sbill_format = getenv('SBILL_FORMAT')
    if env_sbill_format is not None :
        slurm_format_opts = env_sbill_format.split(',')
    else:
        slurm_format_opts = GLOBAL_SBILL_DEFAULT_FORMAT

# Parse format options
len_opt = [-1]*len(slurm_format_opts)
for i in range(len(slurm_format_opts)) :
    temp = slurm_format_opts[i].split('%')
    if len(temp) > 1 and temp[1] != '' :
        len_opt[i] = int(temp[1])
        slurm_format_opts[i] = temp[0]

# Fields to be inquired
sacct_format_opts = slurm_format_opts.copy()
# Fields to be displayed
display_format_opts = slurm_format_opts.copy()

lower_format_opts = [ n.lower() for n in slurm_format_opts ]
j = 0
for i in range(len(lower_format_opts)):
    if 'billing' == lower_format_opts[i] :
        sacct_format_opts.pop(j)
        display_format_opts[i] = 'Billing'
    elif Service.lower() == lower_format_opts[i] :
        sacct_format_opts.pop(j)
        display_format_opts[i] = Service
    elif 'ncpus' == lower_format_opts[i] :
        sacct_format_opts[j] = 'NCPUS'
        display_format_opts[i] = 'NCPUS'
        j += 1
    elif 'ngpus' == lower_format_opts[i] :
        sacct_format_opts.pop(j)
        display_format_opts[i] = 'NGPUS'
    elif CPUusage.lower() == lower_format_opts[i] :
        sacct_format_opts.pop(j)
        display_format_opts[i] = CPUusage
    elif GPUusage.lower() == lower_format_opts[i] :
        sacct_format_opts.pop(j)
        display_format_opts[i] = GPUusage
    elif 'account' == lower_format_opts[i] :
        sacct_format_opts.pop(j)
        display_format_opts[i] = 'Account'
    elif 'state' == lower_format_opts[i] :
        sacct_format_opts.pop(j)
        display_format_opts[i] = 'State'
    else:
        j += 1


if not 'JobID' in sacct_format_opts :
    sacct_format_opts.append('JobID')
if sum_by == 'User' and not 'User' in sacct_format_opts :
    sacct_format_opts.append('User')


# ---- SBILL inquiry SACCT for additional fields

format_opts = ['--format=' + ','.join(sacct_format_opts),'-X','-p','--noheader']
slurm_opts = format_opts + slurm_other_format_opts + slurm_filter_opts + slurm_other_sacct_opts
info = data_from_sacct(slurm_opts, columns=sacct_format_opts, sep='|')

# Merge to usage
usage["Billing"] = usage.pop(key[0])
usage["NGPUS"]   = usage.pop(key[2])

jobid_list = info['JobID'].copy()
last_index = len(usage['JobID']) -1
for k in list(info.keys()):
    iremain = -1
    for i in range(len(jobid_list)):
        if jobid_list[i] == usage['JobID'][iremain+1] :
            iremain += 1
            if iremain == last_index :
                del info[k][iremain+1:]
                break
        else:
            del info[k][iremain+1]

if len(info['JobID']) == len(usage['JobID']) :
    usage.update(info)
else:
    print("You encounter a bug in SBILL, please report this to somrathk@gmail.com")


# ---- Compute sum_by

if len(sum_by) != 0 :
    tags = list(dict.fromkeys( usage[sum_by] ))
    sumby_results = {}
    for t in tags :
        sumby_results[t] = {}
        sumby_results[t][Service] = 0.
        sumby_results[t][CPUusage] = 0.
        sumby_results[t][GPUusage] = 0.
    for i in range(len(usage['JobID'])):
        t = usage[sum_by][i]
        sumby_results[t][Service] += usage[Service][i]
        sumby_results[t][CPUusage] += usage[CPUusage][i]
        sumby_results[t][GPUusage] += usage[GPUusage][i]


# ------------ Print ------------

if not is_show_only_summary :

    # 0. Decimal round + Restrict char/string/text length
    PrintFormat = ''
    HeadFormat = ''
    for i in range(len(display_format_opts)):
        name_opt = display_format_opts[i]
        if len_opt[i] < 0 :
            if name_opt == Service :
                decimal = ServiceDecimal
            elif name_opt == CPUusage :
                decimal = CPUusageDecimal
            elif name_opt == GPUusage :
                decimal = GPUusageDecimal
            else:
                decimal = -1

            if name_opt == 'State' :
                usage[name_opt] = [ x[:x.find(' ')] if x.find(' ')>0 else x for x in usage[name_opt] ]
                num_char = max([len(x) for x in usage[name_opt]]) + 1
            else:
                if decimal < 0 :
                    num_char = max([len(str(x)) for x in usage[name_opt]]) + 1
                else:
                    try_format = '{:,.' + str(decimal) + 'f}'
                    num_char = max([len(try_format.format(x)) for x in usage[name_opt]]) + 1

            num_char = max([len(name_opt)+1, num_char])
            HeadFormat += '{:>' + str(num_char) + '}|'
            if name_opt == Service or name_opt == CPUusage or name_opt == GPUusage :
                PrintFormat += '{:>' + str(num_char) + ',.' + str(decimal) + 'f}|'
            else:
                PrintFormat += '{:>' + str(num_char) + '}|'
        else:
            if name_opt == Service or name_opt == CPUusage or name_opt == GPUusage :
                try_format = '{:,.' + str(len_opt[i]) + 'f}'
                num_char = max([len(try_format.format(x)) for x in usage[name_opt]]) + 2
                num_char = max([len(name_opt)+1, num_char])
                HeadFormat  += '{:>' + str(num_char) + '}|'
                PrintFormat += '{:>' + str(num_char) + ',.' + str(len_opt[i]) + 'f}|'
            else:
                num_char = max([len(name_opt)+1, len_opt[i]+1])
                HeadFormat  += '{:>' + str(num_char) + '}|'
                PrintFormat += '{:>' + str(num_char) + '}|'
                for nr in range(len(usage['JobID'])):
                    usage[name_opt][nr] = str(usage[name_opt][nr])[0:len_opt[i]]

    HeadFormat = HeadFormat.split('|')
    PrintFormat = PrintFormat.split('|')

    # 1. Print table
    for i in range(len(display_format_opts)):
        print(HeadFormat[i].format(display_format_opts[i]), end='')
    print('')

    for nr in range(len(usage['JobID'])) :
        for i in range(len(display_format_opts)) :
            print(PrintFormat[i].format(usage[display_format_opts[i]][nr]), end='')
        print('')
    print('---------- ---------- ---------- ')

# 2. Print filter info
print('')
if len(slurm_filter_opts) != 0 :
    print('With SACCT job filter options: ' + ' '.join(slurm_filter_opts))
if len(state_selected) != 0 or len(range_minmax) >= 1 :
    print('With SBILL job filter options:', end='')
    if len(state_selected) != 0 :
        print(' --state=' + ','.join(state_selected), end='')
    if len(range_minmax) == 1 :
        print(' --range=' + str(range_minmax[0]), end='')
    elif len(range_minmax) > 1 :
        print(' --range=' + str(range_minmax[0]) + '-' + str(range_minmax[1]), end='')
    print('')
print('')

# 3. Print total
Format = '{:,.' + str(ServiceDecimal) + 'f}'
try_service = Format.format(Total_SU_spent).split('.')
Format = '{:,.' + str(CPUusageDecimal) + 'f}'
try_cpu = Format.format(Total_CPUusage_obtained).split('.')
Format = '{:,.' + str(GPUusageDecimal) + 'f}'
try_gpu = Format.format(Total_GPUusage_obtained).split('.')
try_job = '{:,}'.format(len(usage['JobID']))

nl_digit = max([len(try_service[0]), len(try_cpu[0]), len(try_gpu[0]), len(try_job)])
nr_digit = max([ServiceDecimal, CPUusageDecimal, GPUusageDecimal])
Format_L = '{:>' + str(nl_digit) + '}'
Format_R = '.{:<' + str(nr_digit) + '}'

print('{:<30}'.format('Total '+Service+' spent '),'= ', end='')
print(Format_L.format(try_service[0]), end='')
if len(try_service) > 1 :
    print(Format_R.format(try_service[1]))
else:
    print('')

print('{:<30}'.format('Total '+CPUusage+' granted '),'= ', end='')
print(Format_L.format(try_cpu[0]), end='')
if len(try_cpu) > 1 :
    print(Format_R.format(try_cpu[1]))
else:
    print('')

print('{:<30}'.format('Total '+GPUusage+' granted '),'= ', end='')
print(Format_L.format(try_gpu[0]), end='')
if len(try_gpu) > 1 :
    print(Format_R.format(try_gpu[1]))
else:
    print('')

print('{:<30}'.format('Total displayed/filtered jobs '),'= ', end='')
print(Format_L.format(try_job))
print('')

# 4. Additionally print sum_by
if len(sum_by) != 0 :
    sorted_keys = list(sumby_results.keys())
    sorted_keys.sort()
    num_char = max([len(sum_by), max( [len(x) for x in sorted_keys]  )])
    IndexFormat = '{:>' + str(num_char) + '}'
    print(IndexFormat.format(sum_by), end='')

    Decimal = [ServiceDecimal,CPUusageDecimal,GPUusageDecimal]
    Tag     = [Service, CPUusage,GPUusage]
    Format  = ''
    for T,D in zip(Tag, Decimal) :
        try_format = '{:,.' + str(D) + 'f}'
        num_char = 0
        for k in list(sumby_results.keys()):
            num_char = max([num_char, len(try_format.format(sumby_results[k][T]))])
        num_char = max([ len(T), num_char ]) + 2
        Format += '{:>' + str(num_char) + ',.' + str(D) + 'f}|'
        HeadFormat = '{:>' + str(num_char) + '}'
        print(HeadFormat.format(T), end='')
    print('')
    Format = Format.split('|')

    for k in sorted_keys :
        print(IndexFormat.format(k), end='')
        print(Format[0].format(sumby_results[k][Service]), end='')
        print(Format[1].format(sumby_results[k][CPUusage]), end='')
        print(Format[2].format(sumby_results[k][GPUusage]), end='')
        print('')
    print('')

# 5. Additionally print histogram
if is_show_job_histogram :
    from numpy import histogram as hist
    from math import ceil

    if len(range_minmax) >= 2 :
        hist_range = (range_minmax[0], range_minmax[1])
    elif len(range_minmax) == 1 :
        hist_range = (range_minmax[0], max(usage[Service]))
    else:
        hist_range = (0.0, max(usage[Service]))

    count, bin_edges = hist(usage[Service], bins=nbin_histogram, range=hist_range)
    num_char = max( [len('{:,.4f}'.format(x)) for x in bin_edges] ) + 2
    Format = '{:>'+str(num_char)+',.4f} - {:<'+str(num_char)+',.4f}'
    bin_names = [Format.format(x,y) for x,y in zip(bin_edges[:-1],bin_edges[1:])]
    count = list(count)

    step = ceil(max(count)/45)     # at most 45 stars
    #step = int( ceil(step/NUM)*NUM )  # ceil to nearest multiply of NUM
    label = 'Horizontal bar where each x ~ '+str(int(step))+' jobs or less'
    bar = ['x' * int(ceil(n/step)) if n!=0 else ' ' for n in count]

    Format = '{:^' + str(2*num_char+3) + '}'
    print(Format.format(Service+' range'), end='')
    Format = '{:>' + str(len(str(max(count)))+2) + '}'
    print(Format.format('Count'), end='')
    print('   '+label, end='')
    print('')

    for j in range(nbin_histogram):
        print(bin_names[j], end='')
        print(Format.format(count[j]), end='')
        print('   '+bar[j], end='')
        print('')


# ----------- Save to ------------
if csv_outfile != "" :
    with open(csv_outfile, 'w') as f:
        for k in display_format_opts :
            f.write("%s," % k)
        f.write("\n")
        for n in range(len(usage[display_format_opts[0]])):
            for k in display_format_opts :
                f.write("%s," % str(usage[k][n]))
            f.write("\n")

